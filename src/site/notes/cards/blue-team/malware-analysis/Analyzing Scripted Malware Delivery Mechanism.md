---
{"dg-publish":true,"permalink":"/cards/blue-team/malware-analysis/analyzing-scripted-malware-delivery-mechanism/","tags":["malware"]}
---

[[map-of-contents/malware\|malware]] 
### Introduction 
---
There are many ways to deliver scripted malware, one of the most common one is Powershell, Visual Basic Script and to be honest any programming language can be used for malicious purposes.

One of the great things about scripted malware is that it is already handed to us meaning we don't need to actually run the malware or open it up in a debugger.
## Powershell
---
- Some of the syntax are case-insensitive
- `iex` is do whatever we pass as a parameter
- Always try to make sure that the malware will do most of the lifting while defanging it (example below)

```PowerShell
iEx(nEW-ObJECt  Io.CoMpRESSiOn.defLaTEstReam([iO.memoRYStREam][sYsteM.coNvert]::FROmbaSe64StRiNG('bes64encoded'), [sYsTem.io.comprEsSIOn.CoMPReSsIONmOdE]::dEcOMpresS) | % {nEW-ObJECt SYsteM.Io.strEAmReAder($_,[SysTEm.TExT.eNCoDIng]::aSCIi) }| % { $_.reaDtoEnD()})
```

We can simply remove the `iex( )` and replace it with a variable in order to reveal itself - since the malware in overview decodes the base64 into byte array and then the `|` is used to get whatever is the input and encode the input into ASCII and invokes the text.

```
$my_var = code_here_without_the_iex
```

Then `Write-Host $my_var` to reveal:

![Pasted image 20240618155828.png|450](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240618155828.png)
## VBScript: Analyzing a Multi-Stage MSBuild Dropper
---
- Tips here

The malware requires two certificates and a vbscript.
![Pasted image 20240618162922.png](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240618162922.png)

The code:

![Pasted image 20240618163112.png](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240618163112.png)

- It declares the variables
- Creates a object **WScript.Shell** - provides a way to interact with the Windows operating system to open programs, manipulate environment variables, read/write reg keys and display dialog boxes
- Decodes the two cert files
- Executes whatever the string provided by **one.vbs** using the `/c` flag.

![Pasted image 20240618172328.png](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240618172328.png)

- **sub** and **function** difference is sub does not return a value while function is the opposite
- The code performs removing the `vVv` first then getting an object with the `new:....` which is getting a Component Object Model.

![Pasted image 20240618171404.png](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240618171404.png)

- **MSBuild.exe** is used to build .NET applications and C# is included - later on this one
- The `GetObject("new:....")` is to get the object `ShellBrowserWindow` and pass the paramenter basically open up a shell

The command goes like this:

```Vbscript
obj.Document.Application.ShellExecute MSBuild.exe, xml.xml, null,"runas" hide window
```

- `MSBuild.exe` Is the command on what to do other options include are `open`, `print` and more in our case we are building something.
- `xml.xml` - the file or string for the operation
- `null` - additional parameters
- `runas` - run as administrator
- `hide window` - this is actually `1` or `0` - 0 means hide window and one is the opposite.

Then at the `.xml` file, the most interesting one is this - build into a `.cs` file using the `MSBuild.exe` :

![Pasted image 20240618173840.png](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240618173840.png)

The shellcode basically add a new user to the remote desktop group and administrator and opens up RDP if not open yet: `net user`:

![Pasted image 20240618174137.png|450](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240618174137.png)
## HTML Application (HTA)
---
- There will be no process of `.hta` - it is executed in behalf of the `mshta.exe` acts as Interpreter and loads the HTML from the HTA alongside with the required DLLs

Everytime we visit a webpage, our web browser downloads and interprets the following: **HTML, CSS**, and **JAVASCRIPT!**

Cross Site Scripting Example:

![Pasted image 20240618191221.png](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240618191221.png)

- Every `<script>` tag executed - it is only executed **within the browser only**.
- JavaScript can perform activities like hooking the clientâ€™s browser (see the [BeEF Framework](https://beefproject.com/) for an example of this) and downloading files via [HTML Smuggling](https://attack.mitre.org/techniques/T1027/006/).

However _HTML Applications_ is the problem - it is a portable application that is built with HTML, CSS and **Windows Native Scripting Languages (Javascript/Jscript and VBScript)** - this does not execute within the browser but in the operating system.
### Analyzing .HTA
---
Performing static analysis with vscode:

```HTML
<html>
<head>
<title></title>
<body>
<script language="JavaScript" type="text/javascript">
document.write(unescape('%3c%68%74%6d%6c....[snip]......'));
</script>
</body>
</html>
```

- `document.write()` - writes content directly to the HTML document
- `unescape` - decode a string that is encoded using `escape()` - decode from hex

The output:

![Pasted image 20240618192548.png](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240618192548.png)

It is a VBScript that invokes the Windows Management Instrument - It can manage and retrieve information about Windows-based systems, **start and run a process through the Win32_Process** namespace and networks.

Setup WMI using VBScript:
![Pasted image 20240618192931.png](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240618192931.png)

Then it performs by running a command shell that runs powershell and the window is hidden:
![Pasted image 20240618193005.png](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240618193005.png)

Once the powershell is executed:

![Pasted image 20240618193134.png](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240618193134.png)

- HTA is opened and runs the embedded JavaScript.
- The JavaScript decodes the hex bytes of an inner HTML document and writes it into the HTA.
- The inner HTML document invokes VBScript to execute WMI.
- WMI runs a process to call a command shell.
- The command shell, in turn, runs PowerShell in a hidden window.
- PowerShell runs a download cradle command to reach out to `[http://tailofawhale.local/TellAndSentFor.exe](http://tailofawhale.local/TellAndSentFor.exe)`, write it to the %temp% directory as `jLoader.exe` and then execute `jLoader.exe`

Performing dynamic analysis with Inetsim open, it downloads a file:

![Pasted image 20240618193256.png|450](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240618193256.png)

With WireShark - A DNS request and resolution happens:

![Pasted image 20240618193344.png](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240618193344.png)

And the request and response from the malicious domain and the file:

![Pasted image 20240618193404.png](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240618193404.png)

Opening up `procmon` and looking at the `mshta.exe`:

![Pasted image 20240618193627.png](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240618193627.png)

So the PowerShell and the command shell can be found on the `svchost.exe` that has a child process name `wmiprvs.exe` this is the way Windows invokes WMI:

![Pasted image 20240618193838.png](/img/user/cards/blue-team/malware-analysis/images/Pasted%20image%2020240618193838.png)

And all the way down the `jLoader.exe` is what the INetSim spawn.
## Conclusion
---

